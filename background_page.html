<html>
<head>
<script type="text/javascript" src="commands.js"/>
<script type="text/javascript" charset="utf-8">
  // Currently we need to remember to change this each time we push. Chromium #15242 will enable us
  // to retrieve this programmatically.
  var currentVersion = "1.16";

  var tabQueue = {}; // windowId -> Array
  var keyQueue = ""; // Queue of keys typed
  var validFirstKeys = {};
  var singleKeyCommands = [];

  var hasModifierRegex = /^<[amc]-.>/;

  var defaultSettings = {
    scrollStepSize: 60,
    defaultZoomLevel: 100,
    linkHintCharacters: "sadfjklewcmpgh",
    userDefinedLinkHintCss:
      ".vimiumHintMarker {\n\n}\n" +
      ".vimiumHintMarker > .matchingCharacter {\n\n}"
  };

  // This is the base internal link hints CSS. It's combined with the userDefinedLinkHintCss before
  // being sent to the frontend.
  var linkHintCss =
    '.internalVimiumHintMarker {' +
      'position:absolute;' +
      'background-color:yellow;' +
      'color:black;' +
      'font-weight:bold;' +
      'font-size:12px;' +
      'padding:0 1px;' +
      'line-height:100%;' +
      'width:auto;' +
      'display:block;' +
      'border:1px solid #E3BE23;' +
      'z-index:99999999;' +
      'font-family:"Helvetica Neue", "Helvetica", "Arial", "Sans";' +
    '}' +
    '.internalVimiumHintMarker > .matchingCharacter {' +
      'color:#C79F0B;' +
    '}';


  // Port handler mapping
  var portHandlers = {
    keyDown:              handleKeyDown,
    returnScrollPosition: handleReturnScrollPosition,
    isEnabledForUrl:      isEnabledForUrl,
    getCurrentTabUrl:     getCurrentTabUrl,
    getZoomLevel:         getZoomLevel,
    saveZoomLevel:        saveZoomLevel,
    getSetting:           getSetting
  };

  var sendRequestHandlers = {
    getCompletionKeys: getCompletionKeys,
    getLinkHintCss: getLinkHintCss,
    upgradeNotificationClosed: upgradeNotificationClosed
  };

  // Event handlers
  var selectionChangedHandlers = [];
  var getScrollPositionHandlers = {}; // tabId -> function(tab, scrollX, scrollY);
  var tabLoadedHandlers = {}; // tabId -> function()

  chrome.extension.onConnect.addListener(function(port, name) {
    var senderTabId = port.sender.tab ? port.sender.tab.id : null;
    // If this is a tab we've been waiting to open, execute any "tab loaded" handlers, e.g. to restore
    // the tab's scroll position. Wait until domReady before doing this; otherwise operations like restoring
    // the scroll position will not be possible.
    if (port.name == "domReady" && senderTabId != null) {
      if (tabLoadedHandlers[senderTabId]) {
        var toCall = tabLoadedHandlers[senderTabId];
        // Delete first to be sure there's no circular events.
        delete tabLoadedHandlers[senderTabId];
        toCall.call();
      }

      // domReady is the appropriate time to show the "vimium has been upgraded" message.
      if (shouldShowUpgradeMessage())
        chrome.tabs.sendRequest(senderTabId, { name: "showUpgradeNotification", version: currentVersion });
    }

    if (portHandlers[port.name])
      port.onMessage.addListener(portHandlers[port.name]);

  });

  chrome.extension.onRequest.addListener(function (request, sender, sendResponse) {
    var senderTabId = sender.tab ? sender.tab.id : null;
    if (sendRequestHandlers[request.handler])
      sendResponse(sendRequestHandlers[request.handler](request));
  });

  function handleReturnScrollPosition(args) {
    if (getScrollPositionHandlers[args.currentTab.id]) {
      // Delete first to be sure there's no circular events.
      var toCall = getScrollPositionHandlers[args.currentTab.id];
      delete getScrollPositionHandlers[args.currentTab.id];
      toCall(args.currentTab, args.scrollX, args.scrollY);
    }
  }

  /*
   * Used by the content scripts to get their full URL. This is needed for URLs like "view-source:http:// .."
   * because window.location doesn't know anything about the Chrome-specific "view-source:".
   */
  function getCurrentTabUrl(args, port) {
    var returnPort = chrome.tabs.connect(port.tab.id, { name: "returnCurrentTabUrl" });
    returnPort.postMessage({ url: port.tab.url });
  }

  /*
   * Checks the user's preferences in local storage to determine if Vimium is enabled for the given URL.
   */
  function isEnabledForUrl(args, port) {
    var returnPort = chrome.tabs.connect(port.tab.id, { name: "returnIsEnabledForUrl" });
    // excludedUrls are stored as a series of URL expressions separated by newlines.
    var excludedUrls = (localStorage["excludedUrls"] || "").split("\n");
    var isEnabled = true;
    for (var i = 0; i < excludedUrls.length; i++) {
      // The user can add "*" to the URL which means ".*"
      var regexp = new RegExp("^" + excludedUrls[i].replace(/\*/g, ".*") + "$");
      if (args.url.match(regexp))
        isEnabled = false;
    }
    returnPort.postMessage({ isEnabledForUrl: isEnabled });
  }

  /*
   * Returns the previously saved zoom level for the current tab, or the default zoom level
   */
  function getZoomLevel(args, port) {
    var returnPort = chrome.tabs.connect(port.tab.id, { name: "returnZoomLevel" });
    var localStorageKey = "zoom" + args.domain;
    var zoomLevelForDomain = (localStorage[localStorageKey] || "").split(",")[1];
    var zoomLevel = parseInt(zoomLevelForDomain || localStorage["defaultZoomLevel"] ||
        defaultSettings.defaultZoomLevel);
    returnPort.postMessage({ zoomLevel: zoomLevel });
  }

  function showHelp() {
    chrome.tabs.getSelected(null, function(tab) {
      chrome.tabs.sendRequest(tab.id, { name: "showHelpDialog", dialogHtml: helpDialogHtml() });
    });
  }

  /*
   * Retrieves the help dialog HTML template from a file, and populates it with the latest keybindings.
   */
  function helpDialogHtml(showUnboundCommands, showCommandNames, customTitle) {
    var commandsToKey = {};
    for (var key in keyToCommandRegistry) {
      var command = keyToCommandRegistry[key].command;
      commandsToKey[command] = (commandsToKey[command] || []).concat(key);
    }
    var dialogHtml = fetchFileContents("helpDialog.html");
    for (var group in commandGroups)
      dialogHtml = dialogHtml.replace("{{" + group + "}}",
          helpDialogHtmlForCommandGroup(group, commandsToKey, availableCommands,
                                        showUnboundCommands, showCommandNames));
    dialogHtml = dialogHtml.replace("{{version}}", currentVersion);
    dialogHtml = dialogHtml.replace("{{title}}", customTitle || "Help");
    return dialogHtml;
  }

  /*
   * Generates HTML for a given set of commands. commandGroups are defined in commands.js
   */
  function helpDialogHtmlForCommandGroup(group, commandsToKey, availableCommands,
                                         showUnboundCommands, showCommandNames) {
    var html = [];
    for (var i = 0; i < commandGroups[group].length; i++) {
      var command = commandGroups[group][i];
      bindings = (commandsToKey[command] || [""]).join(", ")
      if (showUnboundCommands || commandsToKey[command])
      {
        html.push("<tr><td>", escapeHtml(bindings),
          "</td><td>:</td><td>", availableCommands[command].description);

        if (showCommandNames)
          html.push("<span class='commandName'>(" + command + ")</span>");

        html.push("</td></tr>");
      }
    }
    return html.join("\n");
  }

  function escapeHtml(string) { return string.replace(/</g, "&lt;").replace(/>/g, "&gt;"); }

  /*
   * Fetches the contents of a file bundled with this extension.
   */
  function fetchFileContents(extensionFileName) {
    var req = new XMLHttpRequest();
    req.open("GET", chrome.extension.getURL(extensionFileName), false); // false => synchronous
    req.send();
    return req.responseText;
  }

  /**
   * Returns the keys that can complete a valid command given the current key queue.
   */
  function getCompletionKeys(request) {
    return {completionKeys: generateCompletionKeys()};
  }

  /*
   * Returns the core CSS used for link hints, along with any user-provided overrides.
   */
  function getLinkHintCss(request) {
    return { linkHintCss: linkHintCss + (localStorage['userDefinedLinkHintCss'] || "") };
  }

  /*
   * Called when the user has clicked the close icon on the "Vimium has been updated" message.
   * We should now dismiss that message in all tabs.
   */
  function upgradeNotificationClosed(request) {
    localStorage.previousVersion = currentVersion;
    sendRequestToAllTabs({ name: "hideUpgradeNotification" });
  }

  /*
   * Used by the content scripts to get settings from the local storage.
   */
  function getSetting(args, port) {
    var value = localStorage[args.key] ? localStorage[args.key] : defaultSettings[args.key];

    var returnPort = chrome.tabs.connect(port.tab.id, { name: "returnSetting" });
    returnPort.postMessage({ key: args.key, value: value });
  }

  /*
   * Persists the current zoom level for a given domain
   */
  function saveZoomLevel(args) {
    var localStorageKey = "zoom" + args.domain;
    // TODO(philc): We might want to consider expiring these entries after X months as NoSquint does.
    // Note(philc): We might also want to jsonify this hash instead of polluting our local storage keyspace.
    localStorage[localStorageKey] = [getCurrentTimeInSeconds(), args.zoomLevel].join(",");
  }

  function getCurrentTimeInSeconds() { Math.floor((new Date()).getTime() / 1000); }

  chrome.tabs.onSelectionChanged.addListener(function(tabId, selectionInfo) {
    if (selectionChangedHandlers.length > 0) { selectionChangedHandlers.pop().call(); }
  });

  function repeatFunction(func, totalCount, currentCount) {
    if (currentCount < totalCount)
      func(function() { repeatFunction(func, totalCount, currentCount + 1); });
  }

  // Returns the currently selected tab along with scroll coordinates. Pass in a callback of the form:
  //   function(tab, scrollX, scrollY) { .. }
  function getCurrentTabWithScrollPosition(callback) {
    chrome.tabs.getSelected(null, function(tab) {
      getScrollPositionHandlers[tab.id] = callback;
      var scrollPort = chrome.tabs.connect(tab.id, { name: "getScrollPosition" });
      scrollPort.postMessage({currentTab: tab});
    });
  }

  // Start action functions
  function createTab(callback) {
    chrome.tabs.create({}, function(tab) { callback(); });
  }

  function nextTab() { selectTab("next"); }
  function previousTab() { selectTab("previous"); }

  /*
   * Selects a tab before or after the currently selected tab. Direction is either "next" or "previous".
   */
  function selectTab(direction) {
    chrome.tabs.getAllInWindow(null, function(tabs) {
      if (tabs.length <= 1)
        return;
      for (var i = 0; i < tabs.length; i++) {
        if (tabs[i].selected) {
          var delta = (direction == "next") ? 1 : -1;
          var toSelect = tabs[(i + delta + tabs.length) % tabs.length];
          chrome.tabs.update(toSelect.id, { selected: true });
          break;
        }
      }
    });
  }

  function removeTab(callback) {
    getCurrentTabWithScrollPosition(function(tab, scrollX, scrollY) {
      var tabQueueEntry = { tabUrl: tab.url,
                            scrollX: scrollX,
                            scrollY: scrollY };

      if (tabQueue[tab.windowId])
        tabQueue[tab.windowId].push(tabQueueEntry);
      else
        tabQueue[tab.windowId] = [tabQueueEntry];

      chrome.tabs.remove(tab.id);
      // We can't just call the callback here because we actually need to wait
      // for the selection to change to consider this action done.
      selectionChangedHandlers.push(callback);
    });
  }

  function restoreTab(callback) {
    // TODO(ilya): Should this be getLastFocused instead?
    chrome.windows.getCurrent(function(window) {
      if (tabQueue[window.id] && tabQueue[window.id].length > 0)
      {
        var tabQueueEntry = tabQueue[window.id].pop();

        // Clean out the tabQueue so we don't have unused windows laying about.
        if (tabQueue[window.id].length == 0)
          delete tabQueue[window.id];

        // We have to chain a few callbacks to set the appropriate scroll position. We can't just wait until the
        // tab is created because the content script is not available during the "loading" state. We need to
        // wait until that's over before we can call setScrollPosition.
        chrome.tabs.create({ url: tabQueueEntry.tabUrl }, function(tab) {
          tabLoadedHandlers[tab.id] = function() {
            var scrollPort = chrome.tabs.connect(tab.id, {name: "setScrollPosition"});
            scrollPort.postMessage({ scrollX: tabQueueEntry.scrollX, scrollY: tabQueueEntry.scrollY });
          };

          callback();
        });
      }
    });
  }
  // End action functions

  function splitKeyIntoFirstAndSecond(key) {
    if (key.search(hasModifierRegex) == 0)
      return { first: key.slice(0, 5), second: key.slice(5) };
    else
      return { first: key[0], second: key.slice(1) };
  }

  function getActualKeyStrokeLength(key) {
    if (key.search(hasModifierRegex) == 0)
      return 1 + getActualKeyStrokeLength(key.slice(5));
    else
      return key.length;
  }

  function populateValidFirstKeys() {
    for (var key in keyToCommandRegistry)
    {
      if (getActualKeyStrokeLength(key) == 2)
        validFirstKeys[splitKeyIntoFirstAndSecond(key).first] = true;
    }
  }

  function populateSingleKeyCommands() {
    for (var key in keyToCommandRegistry)
    {
      if (getActualKeyStrokeLength(key) == 1)
        singleKeyCommands.push(key);
    }
  }

  function refreshCompletionKeysAfterMappingSave() {
    validFirstKeys = {};
    singleKeyCommands = [];

    populateValidFirstKeys();
    populateSingleKeyCommands();

    sendRequestToAllTabs({ name: "refreshCompletionKeys", completionKeys: generateCompletionKeys() });
  }

  /*
   * Generates a list of keys that can complete a valid command given the current key queue or the one passed
   * in.
   */
  function generateCompletionKeys(keysToCheck) {
    var splitHash = splitKeyQueue(keysToCheck || keyQueue);
    command = splitHash.command;
    count = splitHash.count;

    var completionKeys = singleKeyCommands.slice(0);

    if (getActualKeyStrokeLength(command) == 1)
    {
      for (var key in keyToCommandRegistry)
      {
        var splitKey = splitKeyIntoFirstAndSecond(key);
        if (splitKey.first == command)
         completionKeys.push(splitKey.second);
      }
    }

    return completionKeys;
  }

  function splitKeyQueue(queue) {
    var match = /([0-9]*)(.*)/.exec(queue);
    var count = parseInt(match[1]);
    var command = match[2];

    return {count: count, command: command};
  }

  function handleKeyDown(key, port) {
    if (key == "<ESC>") {
      console.log("clearing keyQueue");
      keyQueue = ""
    }
    else {
      console.log("checking keyQueue: [", keyQueue + key, "]");
      keyQueue = checkKeyQueue(keyQueue + key, port.tab.id);
      console.log("new KeyQueue: " + keyQueue);
    }
  }

  function checkKeyQueue(keysToCheck, tabId) {
    var refreshedCompletionKeys = false;
    var splitHash = splitKeyQueue(keysToCheck);
    command = splitHash.command;
    count = splitHash.count;

    if (command.length == 0) { return keysToCheck; }
    if (isNaN(count)) { count = 1; }

    if (keyToCommandRegistry[command]) {
      registryEntry = keyToCommandRegistry[command];
      console.log("command found for [", keysToCheck, "],", registryEntry.command);

      if (!registryEntry.isBackgroundCommand) {
        var port = chrome.tabs.connect(tabId, { name: "executePageCommand" });
        port.postMessage({ command: registryEntry.command, count: count,
                            completionKeys: generateCompletionKeys("") });

        refreshedCompletionKeys = true;
      } else {
        repeatFunction(this[registryEntry.command], count, 0);
      }

      newKeyQueue = "";
    } else if (getActualKeyStrokeLength(command) > 1) {
      var splitKey = splitKeyIntoFirstAndSecond(command);

      // The second key might be a valid command by its self.
      if (keyToCommandRegistry[splitKey.second])
        newKeyQueue = checkKeyQueue(splitKey.second);
      else
        newKeyQueue = (validFirstKeys[splitKey.second] ? splitKey.second : "");
    } else {
      newKeyQueue = (validFirstKeys[command] ? count.toString() + command : "");
    }

    // If we haven't sent the completion keys piggybacked on executePageCommand,
    // send them by themselves.
    if (!refreshedCompletionKeys)
    {
      var port = chrome.tabs.connect(tabId, { name: "refreshCompletionKeys" });
      port.postMessage({ completionKeys: generateCompletionKeys(newKeyQueue) });
    }

    return newKeyQueue;
  }

  /*
   * Message all tabs. Args should be the arguments hash used by the Chrome sendRequest API.
   */
  function sendRequestToAllTabs(args) {
    chrome.windows.getAll({ populate: true }, function(windows) {
      for (var i = 0; i < windows.length; i++)
        for (var j = 0; j < windows[i].tabs.length; j++)
          chrome.tabs.sendRequest(windows[i].tabs[j].id, args, null);
    });
  }

  // Compares two version strings (e.g. "1.1" and "1.5") and returns
  // -1 if versionA is < versionB, 0 if they're equal, and 1 if versionA is > versionB.
  function compareVersions(versionA, versionB) {
    versionA = versionA.split(".");
    versionB = versionB.split(".");
    for (var i = 0; i < Math.max(versionA.length, versionB.length); i++) {
      var a = parseInt(versionA[i] || 0);
      var b = parseInt(versionB[i] || 0);
      if (a < b) return -1;
      else if (a > b) return 1;
    }
    return 0;
  }

  /*
   * Returns true if the current extension version is greater than the previously recorded version in
   * localStorage, and false otherwise.
   */
  function shouldShowUpgradeMessage() {
    // Avoid showing the upgrade notification when localStorage.previousVersion is undefined, which is the
    // case for new installs.
    if (!localStorage.previousVersion)
      localStorage.previousVersion = currentVersion;
    return compareVersions(currentVersion, localStorage.previousVersion) == 1;
  }

  function init() {
    clearKeyMappingsAndSetDefaults();

    if (localStorage["keyMappings"])
      parseCustomKeyMappings(localStorage["keyMappings"]);

    populateValidFirstKeys();
    populateSingleKeyCommands();
    if (shouldShowUpgradeMessage())
      sendRequestToAllTabs({ name: "showUpgradeNotification", version: currentVersion });
  }
  init();
</script>
</head>
</html>
